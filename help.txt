создание нового проекта wpf в теминале прямо из vs code:
1. запустить vs code
2. закрыть все открытые проекты
3. открыть терминал (командная строка)
4. зайти в папку, в которой предполагается создать новую папку с проектом wpf 
5. выполнить: dotnet new wpf -n proj_name

в текущей папке создастся папка proj_name со структурой файлов нового проекта wpf.
далее в vs code открываем эту папку и работаем с проектом.

------------------------------------------------------------------------

создание библиотеки для своих контролов wpf в теминале прямо из vs code:
1. запустить vs code
2. закрыть все открытые проекты
3. открыть терминал (командная строка)
4. зайти в папку, в которой предполагается создать библиотеку
5. выполнить: dotnet new wpfusercontrollib -n lib_name

в текущей папке создастся папка lib_nameсо структурой файлов библиотеки wpf.
далее в vs code открываем эту папку и работаем с проектом.
библиотеку нельзя запускать, только компилить.

6. переименовать шаблонные файлы и классы на необходимые имена.

примечание:
	так же можно создать библиотеку простых классов (без xaml):
	dotnet new classlib -n lib_name

------------------------------------------------------------------------

подключение своего шаблонного контрола из библиотеки к конкретному проекту:
1. запустить vs code
2. закрыть все открытые проекты
3. открыть папку, так чтобы папки с проектом и библиотекой были на одном уровне
4. открыть терминал (командная строка)
5. выполнить: dotnet add proj_name reference lib_name
6. открыть файл xaml в проекте, где предполагается использовать шаблонный контрол
7. добавить  строку типа: xmlns:uc="clr-namespace:my_lib_namespace;assembly=my_lib_namespace"
8. далее в разметке добавлять элементы из библиотеки <uc:UCClassName/>

------------------------------------------------------------------------

проброс события от стандартного контрола (создание своего нового события):
1. в теле класса объявить событие и указать типы передаваемых параметров: 
	public event Action<object, type2, type3.....> OnNameEvent;

2. вызвать в необходимом месте, где-то в теле какой-то функции (аналог emit signal QT)
	this.OnNameEvent?.Invoke(this, param1, param2....);

3. подписатья в др. классе на это событие (например в конструкторе)
	obj_name.OnNameEvent += funcname
   так же можно это реализовать в xaml коде по аналогии с обычными контролами	
		
------------------------------------------------------------------------

использование таймера, т.е. вызов какой-то функции с заданным периодом:
1. объявить в классе переменную типа DispatcherTimer
	private DispatcherTimer m_timer = null;
	
2. в конструкторе инициализировать ее и подписатья на событие Tick
	m_timer = new DispatcherTimer();
    m_timer.Interval = new TimeSpan(0, 0, 0, 0, 200); ////dd, hh, min, sec, msec
    m_timer.Tick += timer_Tick;
	
3. объявить и заполнить функцию timer_Tick
	void timer_Tick(object sender, EventArgs e)
	{ /* todo */}
	
4. запуск и останов таймера производится m_timer.Start() и m_timer.Stop(),
	где-то в коде программы согласно логике и алгоритму. (например при нажатии кнопок)
		
	
------------------------------------------------------------------------

кратко про MVVM:
	(Model-View-ViewModel) позволяет отделить логику приложения от визуальной части (представления). 
	Данный паттерн является архитектурным, то есть он задает общую архитектуру приложения.

Модель описывает используемые в приложении данные. Модели могут содержать логику, непосредственно связанную этими данными, например, логику валидации свойств модели. 
В то же время модель не должна содержать никакой логики, связанной с отображением данных и взаимодействием с визуальными элементами управления.

View или представление определяет визуальный интерфейс, через который пользователь взаимодействует с приложением. 
Применительно к WPF представление - это код в xaml, который определяет интерфейс в виде кнопок, текстовых полей и прочих визуальных элементов.
WPF может содержать как интерфейс в xaml, так и привязанный к нему код C#, однако в идеале код C# не должен содержать какой-то логики, кроме конструктора, 
который вызывает метод InitializeComponent и выполняет начальную инициализацию окна. Вся же основная логика приложения выносится в компонент ViewModel.

ViewModel или модель представления связывает модель и представление через механизм привязки данных. 
Если в модели изменяются значения свойств, при реализации моделью интерфейса INotifyPropertyChanged автоматически идет изменение отображаемых данных в представлении, 
хотя напрямую модель и представление не связаны. ViewModel также содержит логику по получению данных из модели, которые потом передаются в представление. 
И также VewModel определяет логику по обновлению данных в модели.
Поскольку элементы представления, то есть визуальные компоненты типа кнопок, не используют события, то представление взаимодействует с ViewModel посредством команд.

------------------------------------------------------------------------

создание нового свойства типа DependencyProperty в UserControl, привязка своего свойства в UserControl:

1. зарегистрировать новое свойство зависимостей:
	public static readonly DependencyProperty [DPNewUserProperty] =
            DependencyProperty.Register("[NewPropertyName]", typeof(string), typeof([MyUserControlClassName]));

2. объявить и описать новое свойство:
        public string [NewPropertyName]
        {
            get {return (string)GetValue([DPNewUserProperty]);}
            set {SetValue([DPNewUserProperty], value);  и возможно что-то еще.}
        }

3. в файле xaml:
	a) дать имя заглавному элементу, например: x:Name=[UC_Root]
	b) сделать привязку свойства в каком-нибудь поле: Text="{Binding ElementName=[UC_Root], Path=[NewPropertyName]}

4. из вне можно менять и привязываться к свойству [NewPropertyName] при необходимости

------------------------------------------------------------------------

сборка Release версии:
	dotnet build -c Release [proj_name]

------------------------------------------------------------------------
применение конвертера значений в привязке:
	смысл конвертера - из одного типа данных выдать другой тип, например из строки => картинку, 
	для таких преобразований надо реализовать специальный класс а затем применить объект этого класса в описании привязки.


	1.    Создать класс, реализующий IValueConverter.
	2.    Добавить атрибут ValueConversion в объявление класса и указать исходный и целевой типы данных.
	3.    Реализовать метод Convert(), преобразующий данные из исходного формата в отображаемый формат.
	4.    Реализовать метод ConvertBack(), выполняющий обратное преобразование значения из отображаемого формата в его "родной" формат,
			если это не нужно можно просто в теле функции написать: return null;

пример:
public class ImagePathConverter : IValueConverter
{
        public object Convert(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
        {
            return new BitmapImage(
                	new Uri(System.IO.Directory.GetCurrentDirectory() + "\\" + (string)value));
        }
        public object ConvertBack(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
        {
            return null;
        }
}
------------------------------------------------------------------------
асинхронные методы с применением ключевых слов async и await 
 1. пишем некоторый метод как обычно: void funcName(params)
 2. пишем асинхронный метод который будет запускать  метод  funcName() в отдельной нити
        public async void funcNameAsync(params)
        {
            //выполление в основной нити		 
	    line code 1
	    line code 2
	    line code 3

            // начиная с этой строки функция какбы уходит в другую нить
            await Task.Run(()=>funcName(params));

            //выполнится только после окончания выполнения funcName()		 
	    line code 4
	    line code 5
	    line code 6
        } 
   3. вызов асинхонной функции где-то в коде
	public void func2()
	{
            //выполление в основной нити		 
	    line code 1

            // асинхронная функция
	    funcNameAsync(params);

            //выполнится сразу после запуска funcNameAsync(), не дожидаясь окончания ее выполнения
	    line code 2
	}
----------------------------------------------------------
  создание дистрибутива с помощью команды dotnet publish
  1. создать легкую версию набора файлов, предполагается что на том компе где будет запускаться прога уже установлен пакет .Net 
	dotnet publish proj_name -c release -o path_distr
	- proj_name имя папки с проектом
        - path_distr имя папку где будет создан набор файлов дистрибутива
  2. создать тяжелю полную версию набора файлов, предполагается что исполняемый файл можно запустить на голой системе
	dotnet publish proj_name -c release -o path_distr -r win-x64
	- win-x64 тип и разрядность системы, где будет запущено приложение (см. в интернете весь набор систем таких как MAC, Linux)
  3. создать тяжелю-урезанную полную версию набора файлов, эта версия чуть легче чем из п.2, можно сначала ее испытать, если приложение не запустится то делать версию из п.2
	dotnet publish diff_bin -c release -o mydistrs/diffbin4 -r win-x64 -p:PublishTrimmed=true






 